--tphub
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- æŒ‡å®šã•ã‚ŒãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰Orionã‚’ãƒ­ãƒ¼ãƒ‰
local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/jadpy/suki/refs/heads/main/orion"))()

-- ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½œæˆ
local Window = OrionLib:MakeWindow({
Name = "tp-hub V3.5",
HidePremium = false,
SaveConfig = true,
ConfigFolder = "OrionTest"
})


---

-- ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ã®ãƒ­ã‚¸ãƒƒã‚¯ (tp-hub)

local originalColors
if ReplicatedStorage:FindFirstChild("DataEvents") and ReplicatedStorage.DataEvents:FindFirstChild("UpdateLineColorsEvent") then
originalColors = {}
for i = 1, 10 do
table.insert(originalColors, Color3.new(1,1,1))
end
end

local ToggleState = false
local hueOffset = 0

local function FireRainbowColors()
if ReplicatedStorage:FindFirstChild("DataEvents") and ReplicatedStorage.DataEvents:FindFirstChild("UpdateLineColorsEvent") then
local cs = ColorSequence.new{
ColorSequenceKeypoint.new(0, Color3.fromHSV((0+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.1, Color3.fromHSV((0.1+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.2, Color3.fromHSV((0.2+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.3, Color3.fromHSV((0.3+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.4, Color3.fromHSV((0.4+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.5, Color3.fromHSV((0.5+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.6, Color3.fromHSV((0.6+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.7, Color3.fromHSV((0.7+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.8, Color3.fromHSV((0.8+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(0.9, Color3.fromHSV((0.9+hueOffset)%1,1,1)),
ColorSequenceKeypoint.new(1, Color3.fromHSV((1+hueOffset)%1,1,1))
}
ReplicatedStorage.DataEvents.UpdateLineColorsEvent:FireServer(cs, cs.Keypoints[1].Value, cs.Keypoints[2].Value, cs.Keypoints[3].Value, cs.Keypoints[4].Value, cs.Keypoints[5].Value, cs.Keypoints[6].Value, cs.Keypoints[7].Value, cs.Keypoints[8].Value, cs.Keypoints[9].Value)
end
end

RunService.Heartbeat:Connect(function()
if ToggleState then
hueOffset = (hueOffset + 0.005) % 1
FireRainbowColors()
end
end)


---

-- ç¿¼MOD æ©Ÿèƒ½ã®ãƒ­ã‚¸ãƒƒã‚¯ (WINGS MOD)

local Enabled = false
local Spacing = 0.0
local WingHeight = 2.0  -- ä¸­å¿ƒã«å¯„ã›ã‚‹ãŸã‚é«˜ã•ã‚’ä¸‹ã’ã¾ã—ãŸï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ20ã‹ã‚‰ä¿®æ­£ï¼‰
local BackOffset = 0.5  -- ä½“ã«å¯†ç€ã•ã›ã‚‹ãŸã‚0.5ã«èª¿æ•´
local SideOffset = 0.0
local WaveAmplitude = 2.5
local WaveSpeed = 5.0
local TwistAngle = 20.0
local TwistSpeed = 5.0
local TwistWave = 0.5
local TargetSet = "Sparkler"
local defaultMaxZoom = 12
local maxZoom5000Enabled = false

local TargetSets = {
["GlassBox"] = {"GlassBoxGray"},
["Pallet"] = {"PalletLightBrown"},
["Sparkler"] = {"FireworkSparkler"},
["Toilet"] = {"ToiletWhite","ToiletGold"},
["Piano"] = {"KeyboardPart", "MusicKeyboard"},
["Stick"] = {"Stick"} -- Stickã‚’è¿½åŠ 
}

local list, loopConn = {}, nil
local tAccum = 0

local function HRP()
local c = LP.Character or LP.CharacterAdded:Wait()
return c:FindFirstChild("HumanoidRootPart")
end
local function getPartFromModel(m)
if m.PrimaryPart then return m.PrimaryPart end
return m:FindFirstChildWhichIsA("BasePart")
end
local function nameInTargets(n)
local t = TargetSets[TargetSet]
if not t then return false end
for _, nm in ipairs(t) do if n == nm then return true end end
return false
end

local function attachPhysics(rec)
local model = rec.model; local part = rec.part
if not model or not part or not part.Parent then return end
for _, p in ipairs(model:GetDescendants()) do
if p:IsA("BasePart") and not p:IsA("BodyMover") then
pcall(function() p:SetNetworkOwner(LP) end)
p.CanCollide, p.CanTouch = false, false
end
end
if not part:FindFirstChild("BodyVelocity") then
local bv = Instance.new("BodyVelocity", part); bv.Name = "BodyVelocity"; bv.MaxForce = Vector3.new(1e8,1e8,1e8); bv.Velocity = Vector3.new(); bv.P = 1e6
end
if not part:FindFirstChild("BodyGyro") then
local bg = Instance.new("BodyGyro", part); bg.Name = "BodyGyro"; bg.MaxTorque = Vector3.new(1e8,1e8,1e8); bg.CFrame = part.CFrame; bg.P = 1e6
end
end

local function detachPhysics(rec)
local model = rec.model; local part = rec.part
if not model or not part then return end
if part:FindFirstChild("BodyVelocity") then part.BodyVelocity:Destroy() end
if part:FindFirstChild("BodyGyro") then part.BodyGyro:Destroy() end
for _, p in ipairs(model:GetDescendants()) do
if p:IsA("BasePart") and not p:IsA("BodyMover") then
p.CanCollide, p.CanTouch = true, true
pcall(function() p:SetNetworkOwner(nil) end)
end
end
end

local function rescan()
for _,r in ipairs(list) do detachPhysics(r) end
list = {}
for _, d in ipairs(Workspace:GetDescendants()) do
if d:IsA("Model") and nameInTargets(d.Name) then
local part = getPartFromModel(d)
if part and not part.Anchored then table.insert(list, {model=d, part=part}) end
elseif d:IsA("BasePart") and nameInTargets(d.Name) then -- ãƒ‘ãƒ¼ãƒ„å˜ä½“ã«ã‚‚å¯¾å¿œ
if not d.Anchored then table.insert(list, {model=d, part=d}) end
end
end
for i = 1, #list do attachPhysics(list[i]) end
end

local function startLoop()
if loopConn then loopConn:Disconnect() end
tAccum = 0
loopConn = RunService.Heartbeat:Connect(function(dt)
local root = HRP()
if not root or #list == 0 then return end
tAccum = tAccum + dt
-- è‡ªåˆ†ã®ä¸­å¿ƒã«å¯„ã›ã‚‹ãŸã‚ã®CFrameèª¿æ•´
local wingsCenter = root.CFrame * CFrame.new(SideOffset, WingHeight, BackOffset)
local WaveConstant = math.pi / #list
for j = 1, #list do
local rec = list[j]; local p = rec.part
if p and p.Parent then
local isRight = (j % 2 == 0); local sign = isRight and 1 or -1
local animationIndex = math.ceil(j / 2)
local distanceIndex = isRight and (j - 2) / 2 or (j - 1) / 2

-- SpacingãŒ0ã«è¿‘ã„ã»ã©ä¸­å¿ƒã«é›†ã¾ã‚‹
local xOffset = Spacing * (distanceIndex + 0.2) * sign
local waveOffset = WaveAmplitude * math.sin(WaveSpeed * tAccum + animationIndex * WaveConstant)
local twistOscillation = math.sin(TwistSpeed * tAccum + animationIndex * TwistWave)
local currentTwistAngle = math.rad(TwistAngle * twistOscillation * (distanceIndex / (#list / 2)))

local targetCFrame = wingsCenter * CFrame.Angles(currentTwistAngle, 0, 0) * CFrame.new(xOffset, waveOffset, 0)    
        if p:FindFirstChild("BodyVelocity") then p.BodyVelocity.Velocity = (targetCFrame.Position - p.Position) * 20 end    
        if p:FindFirstChild("BodyGyro") then p.BodyGyro.CFrame = targetCFrame end    
    end    
end

end)

end


---

-- ã‚¿ãƒ–æ§‹æˆ

-- æƒ…å ±ã‚¿ãƒ–
local InfoTab = Window:MakeTab({
Name = "æƒ…å ±",
Icon = "rbxassetid://4483345998",
PremiumOnly = false
})

InfoTab:AddLabel("Credit: BGHACKERS / Logfeetst")

InfoTab:AddButton({
Name = "Discordãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼",
Callback = function()
setclipboard("https://discord.gg/Ghn3cjjHem")
OrionLib:MakeNotification({Name = "ã‚³ãƒ”ãƒ¼å®Œäº†", Content = "ãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ãŸãœã€ãƒã‚¹ã‚¿ãƒ¼ã€‚", Time = 3})
end
})

-- ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã‚¿ãƒ–
local LineTab = Window:MakeTab({
Name = "Line Color",
Icon = "rbxassetid://4483345998",
PremiumOnly = false
})

LineTab:AddToggle({
Name = "Rainbow Lines (FTAP ONLY)",
Default = false,
Callback = function(Value)
ToggleState = Value
if not Value and originalColors then
ReplicatedStorage.DataEvents.UpdateLineColorsEvent:FireServer(originalColors[1],originalColors[2],originalColors[3],originalColors[4],originalColors[5],originalColors[6],originalColors[7],originalColors[8],originalColors[9],originalColors[10])
end
end
})

-- ãƒ†ãƒ¬ãƒãƒ¼ãƒˆã‚¿ãƒ–
local TPTab = Window:MakeTab({
Name = "ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ",
Icon = "rbxassetid://4483345998",
PremiumOnly = false
})

local function Teleport(coords)
local player = game.Players.LocalPlayer
if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
player.Character.HumanoidRootPart.CFrame = CFrame.new(coords)
end
end

TPTab:AddSection({Name = "å„æ‹ ç‚¹ã¸ã®ç§»å‹•"})
TPTab:AddButton({ Name = "ãƒ”ãƒ³ã‚¯ã®å®¶ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ", Callback = function() Teleport(Vector3.new(-481.23, -7.35, -149.67)) end })
TPTab:AddButton({ Name = "ç·‘ã®å®¶ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ", Callback = function() Teleport(Vector3.new(-546.02, -7.35, 78.07)) end })
TPTab:AddButton({ Name = "èµ¤ã„å®¶ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ", Callback = function() Teleport(Vector3.new(542.11, 123.34, -91.78)) end })
TPTab:AddButton({ Name = "æ°´è‰²ã®å®¶ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ", Callback = function() Teleport(Vector3.new(496.99, 83.34, -350.96)) end })

-- ç¿¼MODã‚¿ãƒ–
local WingTab = Window:MakeTab({
Name = "WINGS",
Icon = "rbxassetid://6031075927",
PremiumOnly = false
})

WingTab:AddDropdown({
Name = "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ",
Default = TargetSet,
Options = {"Stick", "Sparkler","Toilet", "Piano", "GlassBox", "Pallet"},
Callback = function(v) TargetSet = v; if Enabled then rescan() end end
})

WingTab:AddToggle({
Name = "ç¾½èµ·å‹•/åœæ­¢",
Default = false,
Callback = function(v)
Enabled = v
if v then rescan(); startLoop() else if loopConn then loopConn:Disconnect() end; for _,rec in ipairs(list) do detachPhysics(rec) end; list = {} end
end
})

WingTab:AddButton({
Name = "Fly GUI v3 èµ·å‹•",
Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/XNEOFF/FlyGuiV3/main/FlyGuiV3.txt"))()
end
})

WingTab:AddSlider({ Name = "ç¿¼ã®åºƒã• (Spacing)", Min = 0, Max = 5, Default = 0.2, Increment = 0.1, Callback = function(v) Spacing = v end })
WingTab:AddSlider({ Name = "ç¿¼ã®é«˜ã• (Height)", Min = -10, Max = 100, Default = 2, Increment = 1, Callback = function(v) WingHeight = v end })

WingTab:AddToggle({
Name = "ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ  2000",
Default = false,
Callback = function(v)
maxZoom5000Enabled = v
LP.CameraMaxZoomDistance = v and 5000 or defaultMaxZoom
end
})

OrionLib:Init()
LP.CameraMode = Enum.CameraMode.Classic
LP.CameraMinZoomDistance = 0.5

-- ESP æ©Ÿèƒ½ï¼ˆè¿½åŠ ã®ã¿ãƒ»æ—¢å­˜ã‚³ãƒ¼ãƒ‰ä¸å¹²æ¸‰ï¼‰

local ESPEnabled = false
local ESPObjects = {}

local function getHeadshot(userId)
return "https://www.roblox.com/headshot-thumbnail/image?userId="
.. userId .. "&width=150&height=150&format=png"
end

local function createESP(player)
if player == LP then return end
if ESPObjects[player] then return end

local gui = Instance.new("BillboardGui")
gui.Name = "TPHubESP"
gui.Size = UDim2.new(0, 220, 0, 90)
gui.StudsOffset = Vector3.new(0, 2.5, 0)
gui.AlwaysOnTop = true

local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.fromRGB(20,20,20)
frame.BackgroundTransparency = 0.2
frame.BorderSizePixel = 1
frame.Parent = gui

Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

local img = Instance.new("ImageLabel")
img.Size = UDim2.new(0, 64, 0, 64)
img.Position = UDim2.new(0, 6, 0, 12)
img.BackgroundTransparency = 1
img.Image = getHeadshot(player.UserId)
img.Parent = frame

local nameLabel = Instance.new("TextLabel")
nameLabel.Position = UDim2.new(0, 80, 0, 18)
nameLabel.Size = UDim2.new(1, -90, 0, 22)
nameLabel.BackgroundTransparency = 1
nameLabel.Text = player.DisplayName
nameLabel.TextColor3 = Color3.new(1,1,1)
nameLabel.TextScaled = true
nameLabel.Font = Enum.Font.GothamBold
nameLabel.Parent = frame

local idLabel = Instance.new("TextLabel")
idLabel.Position = UDim2.new(0, 80, 0, 42)
idLabel.Size = UDim2.new(1, -90, 0, 20)
idLabel.BackgroundTransparency = 1
idLabel.Text = "ID : "..player.UserId
idLabel.TextColor3 = Color3.fromRGB(180,180,180)
idLabel.TextScaled = true
idLabel.Font = Enum.Font.Gotham
idLabel.Parent = frame

ESPObjects[player] = gui

local function attach()
if player.Character and player.Character:FindFirstChild("Head") then
gui.Parent = player.Character.Head
end
end

attach()
player.CharacterAdded:Connect(function()
task.wait(1)
attach()
end)

end

local function removeAllESP()
for _, gui in pairs(ESPObjects) do
if gui then gui:Destroy() end
end
ESPObjects = {}
end

Players.PlayerAdded:Connect(function(player)
if ESPEnabled then
createESP(player)
end
end)


---

-- ESP ã‚¿ãƒ–ï¼ˆè¿½åŠ ã®ã¿ï¼‰

local ESPTab = Window:MakeTab({
Name = "ESP",
Icon = "rbxassetid://4483345998",
PremiumOnly = false
})

ESPTab:AddToggle({
Name = "ESP æœ‰åŠ¹ï¼ˆåå‰ / ID / é¡”ï¼‰",
Default = false,
Callback = function(value)
ESPEnabled = value
if value then
for _, player in ipairs(Players:GetPlayers()) do
createESP(player)
end
else
removeAllESP()
end
end
})-------------------------------------------------------------------
-- WINGS å›è»¢æ©Ÿèƒ½ï¼ˆå®Œå…¨è¿½åŠ ãƒ»æ—¢å­˜ã‚³ãƒ¼ãƒ‰ä¸å¹²æ¸‰ï¼‰

local SpinEnabled = false
local SpinSpeed = 10 -- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10ï¼ˆæœ€å¤§20ï¼‰

-- è‡ªã‚­ãƒ£ãƒ©é«˜é€Ÿå³å›è»¢
RunService.Heartbeat:Connect(function()
if not SpinEnabled then return end
local char = LP.Character
local hrp = char and char:FindFirstChild("HumanoidRootPart")
if hrp then
hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0)
end
end)

-- WINGS ã‚¿ãƒ–ã«UIè¿½åŠ ï¼ˆä»–ã¯ä¸€åˆ‡å¤‰æ›´ã—ãªã„ï¼‰
WingTab:AddToggle({
Name = "å›è»¢ï¼ˆå³ã‚¹ãƒ”ãƒ³ï¼‰",
Default = false,
Callback = function(v)
SpinEnabled = v
end
})

WingTab:AddSlider({
Name = "å›è»¢ã‚¹ãƒ”ãƒ¼ãƒ‰",
Min = 1,
Max = 20,
Default = 10,
Increment = 1,
Callback = function(v)
SpinSpeed = v
end
})

-- WINGS å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é¸æŠï¼ˆå®Œå…¨è¿½åŠ ï¼‰

local WingsTargetPlayer = nil
local WingsTargetEnabled = false
local targetLoopConn = nil

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åãƒªã‚¹ãƒˆå–å¾—
local function getPlayerNameList()
local t = {"è‡ªåˆ†"}
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= LP then
table.insert(t, plr.Name)
end
end
return t
end

local function getTargetHRP()
if not WingsTargetEnabled or not WingsTargetPlayer then
return HRP()
end
if WingsTargetPlayer.Character then
return WingsTargetPlayer.Character:FindFirstChild("HumanoidRootPart")
end
return nil
end

-- å¯¾è±¡ç”¨Wingsãƒ«ãƒ¼ãƒ—ï¼ˆæ—¢å­˜Wingsã¨ã¯å®Œå…¨åˆ¥ï¼‰
local function startTargetLoop()
if targetLoopConn then targetLoopConn:Disconnect() end
targetLoopConn = RunService.Heartbeat:Connect(function(dt)
local root = getTargetHRP()
if not root or #list == 0 then return end

tAccum = tAccum + dt
local wingsCenter = root.CFrame * CFrame.new(SideOffset, WingHeight, BackOffset)
local WaveConstant = math.pi / #list

for j = 1, #list do    
    local rec = list[j]    
    local p = rec.part    
    if p and p.Parent then    
        local isRight = (j % 2 == 0)    
        local sign = isRight and 1 or -1    
        local animationIndex = math.ceil(j / 2)    
        local distanceIndex = isRight and (j - 2) / 2 or (j - 1) / 2    

        local xOffset = Spacing * (distanceIndex + 0.2) * sign    
        local waveOffset = WaveAmplitude * math.sin(WaveSpeed * tAccum + animationIndex * WaveConstant)    
        local twistOscillation = math.sin(TwistSpeed * tAccum + animationIndex * TwistWave)    
        local currentTwistAngle = math.rad(TwistAngle * twistOscillation)    

        local targetCFrame =    
            wingsCenter    
            * CFrame.Angles(currentTwistAngle, 0, 0)    
            * CFrame.new(xOffset, waveOffset, 0)    

        if p:FindFirstChild("BodyVelocity") then    
            p.BodyVelocity.Velocity = (targetCFrame.Position - p.Position) * 20    
        end    
        if p:FindFirstChild("BodyGyro") then    
            p.BodyGyro.CFrame = targetCFrame    
        end    
    end    
end

end)

end


---

-- WINGS å¸ç€ä¿®æ­£ï¼ˆHRPå†å®šç¾©ãƒ»æ—¢å­˜ã‚³ãƒ¼ãƒ‰å®Œå…¨ä¸å¹²æ¸‰ï¼‰

local WingsTargetPlayer = nil

-- HRP ã‚’å†å®šç¾©ï¼ˆLuaä»•æ§˜ã§ä¸Šæ›¸ãï¼‰
function HRP()
-- ä»–äººãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆ
if WingsTargetPlayer
and WingsTargetPlayer.Character
and WingsTargetPlayer.Character:FindFirstChild("HumanoidRootPart") then

return WingsTargetPlayer.Character.HumanoidRootPart
end

-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆè‡ªåˆ†ï¼‰
local c = LP.Character or LP.CharacterAdded:Wait()
return c:FindFirstChild("HumanoidRootPart")

end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€è¦§
local function getPlayerList()
local t = {"è‡ªåˆ†"}
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= LP then
table.insert(t, plr.Name)
end
end
return t
end

-- WINGS ã‚¿ãƒ–ã«å¯¾è±¡é¸æŠã‚’è¿½åŠ 
WingTab:AddDropdown({
Name = "WINGS å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
Default = "è‡ªåˆ†",
Options = getPlayerList(),
Callback = function(v)
if v == "è‡ªåˆ†" then
WingsTargetPlayer = nil
else
WingsTargetPlayer = Players:FindFirstChild(v)
end
end
})

-- WINGS ç«œå·»ãƒ¢ãƒ¼ãƒ‰ï¼ˆç¾½ONä¸è¦ãƒ»å›ºå®šå€¤ãƒ»å®Œå…¨è¿½åŠ ï¼‰

local TornadoEnabled = false

-- å›ºå®šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼ˆå¤‰æ›´ä¸å¯ï¼‰
local TORNADO_RADIUS = 13.5
local TORNADO_HEIGHT = 23
local TORNADO_SPIN_SPEED = 4

local tornadoConn = nil

local function startTornado()
if tornadoConn then tornadoConn:Disconnect() end

-- å¯¾è±¡ã‚’å³ã‚¹ã‚­ãƒ£ãƒ³ï¼ˆç¾½ONä¸è¦ï¼‰  
rescan()  

tornadoConn = RunService.Heartbeat:Connect(function(dt)  
    local root = HRP()  
    if not root or #list == 0 then return end  

    tAccum += dt  
    local baseCF = root.CFrame  

    for i, rec in ipairs(list) do  
        local p = rec.part  
        if p and p.Parent then  
            local heightOffset = (i / #list) * TORNADO_HEIGHT  
            local angle =  
                (tAccum * TORNADO_SPIN_SPEED)  
                + (i * math.pi * 2 / #list)  

            local x = math.cos(angle) * TORNADO_RADIUS  
            local z = math.sin(angle) * TORNADO_RADIUS  
            local y = heightOffset  

            local targetCFrame =  
                baseCF  
                * CFrame.new(x, y, z)  
                * CFrame.Angles(0, angle, 0)  

            if p:FindFirstChild("BodyVelocity") then  
                p.BodyVelocity.Velocity =  
                    (targetCFrame.Position - p.Position) * 30  
            end  

            if p:FindFirstChild("BodyGyro") then  
                p.BodyGyro.CFrame = targetCFrame  
            end  
        end  
    end  
end)

end

local function stopTornado()
if tornadoConn then
tornadoConn:Disconnect()
tornadoConn = nil
end

-- å¾Œå‡¦ç†  
for _, rec in ipairs(list) do  
    detachPhysics(rec)  
end  
list = {}

end

-- UIï¼ˆWINGSã‚¿ãƒ–ã«ãƒˆã‚°ãƒ«ã®ã¿è¿½åŠ ï¼‰
WingTab:AddToggle({
Name = "ç«œå·»ãƒ¢ãƒ¼ãƒ‰",
Default = false,
Callback = function(v)
TornadoEnabled = v

if v then  
        -- ç¾½ãƒ«ãƒ¼ãƒ—ãŒå‹•ã„ã¦ãŸã‚‰æ­¢ã‚ã‚‹  
        if loopConn then loopConn:Disconnect() end  
        startTornado()  
    else  
        stopTornado()  
        -- ç¾½ONçŠ¶æ…‹ãªã‚‰è‡ªå‹•å¾©å¸°  
        if Enabled then  
            rescan()  
            startLoop()  
        end  
    end  
end

})

-- WINGS å††ãƒ¢ãƒ¼ãƒ‰ï¼ˆç¾½ONä¸è¦ãƒ»å›ºå®šå€¤ãƒ»å®Œå…¨è¿½åŠ ï¼‰

local CircleEnabled = false

-- å›ºå®šå€¤ï¼ˆå¤‰æ›´ä¸å¯ï¼‰
local CIRCLE_RADIUS = 13.5
local CIRCLE_HEIGHT = 2
local CIRCLE_SPEED = 10

local circleConn = nil

local function startCircle()
if circleConn then circleConn:Disconnect() end

-- ç¾½ONä¸è¦ã§å³å–å¾—  
rescan()  

circleConn = RunService.Heartbeat:Connect(function(dt)  
    local root = HRP()  
    if not root or #list == 0 then return end  

    tAccum += dt  
    local baseCF = root.CFrame  

    for i, rec in ipairs(list) do  
        local p = rec.part  
        if p and p.Parent then  
            local angle =  
                (i / #list) * math.pi * 2  
                + (tAccum * CIRCLE_SPEED)  

            local x = math.cos(angle) * CIRCLE_RADIUS  
            local z = math.sin(angle) * CIRCLE_RADIUS  
            local y = CIRCLE_HEIGHT  

            local targetCFrame =  
                baseCF  
                * CFrame.new(x, y, z)  
                * CFrame.Angles(0, angle, 0)  

            if p:FindFirstChild("BodyVelocity") then  
                p.BodyVelocity.Velocity =  
                    (targetCFrame.Position - p.Position) * 30  
            end  

            if p:FindFirstChild("BodyGyro") then  
                p.BodyGyro.CFrame = targetCFrame  
            end  
        end  
    end  
end)

end

local function stopCircle()
if circleConn then
circleConn:Disconnect()
circleConn = nil
end

for _, rec in ipairs(list) do  
    detachPhysics(rec)  
end  
list = {}

end

-- UIï¼ˆWINGSã‚¿ãƒ–ã«ãƒˆã‚°ãƒ«1å€‹ã ã‘ï¼‰
WingTab:AddToggle({
Name = "å††ãƒ¢ãƒ¼ãƒ‰",
Default = false,
Callback = function(v)
CircleEnabled = v

if v then  
        -- ç¾½ / ç«œå·» / æ˜Ÿ ãŒå‹•ã„ã¦ãŸã‚‰æ­¢ã‚ã‚‹  
        if loopConn then loopConn:Disconnect() end  
        if tornadoConn then tornadoConn:Disconnect() end  
        startCircle()  
    else  
        stopCircle()  
        -- ç¾½ONçŠ¶æ…‹ãªã‚‰è‡ªå‹•å¾©å¸°  
        if Enabled then  
            rescan()  
startLoop()  
        end  
    end  
end

})

-- WINGS è­¦å‘Šè¡¨ç¤ºï¼ˆä¸€ç•ªä¸‹ã«è²¼ã‚‹ã ã‘ã§OKï¼‰

task.delay(0.5, function()
OrionLib:MakeNotification({
Name = "âš ï¸ è­¦å‘Š",
Content = "ç¾åœ¨ Stick ä»¥å¤–ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“",
Time = 4
})
end)
-------------------------------------------------------------------
-- WINGS ç¾½ã°ãŸãå¼·åŒ–ï¼ˆå¾Œä»˜ã‘ãƒ»ä¸‹ã«è²¼ã‚‹ã ã‘ï¼‰

local ExtraFlapPower = 1 -- 0ã€œ10

-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¿½åŠ ï¼ˆæ—¢å­˜UIã«å¹²æ¸‰ã—ãªã„ï¼‰
WingTab:AddSlider({
    Name = "ç¾½ã®æŒ¯å‹•ãƒ‘ãƒ¯ãƒ¼",
    Min = 0,
    Max = 10,
    Default = 1,
    Increment = 0.5,
    Callback = function(v)
        ExtraFlapPower = v
    end
})

-- ç¾½ã°ãŸãå¢—å¹…ï¼ˆæ—¢å­˜ãƒ«ãƒ¼ãƒ—ã‚’å£Šã•ãªã„ï¼‰
RunService.Heartbeat:Connect(function()
    if not Enabled then return end
    if #list == 0 then return end

    -- WaveAmplitude ã‚’ä¸€æ™‚çš„ã«å¼·åŒ–
    _G.__WingOriginalAmp = _G.__WingOriginalAmp or WaveAmplitude
    WaveAmplitude = _G.__WingOriginalAmp * (1 + ExtraFlapPower)
end)
-------------------------------------------------------------------

-- ã€ç¢ºå®šç‰ˆã€‘ç«œå·»ï¼†å††ãƒ¢ãƒ¼ãƒ‰ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ»ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãƒ»ã‚»ã‚¯ã‚·ãƒ§ãƒ³
-------------------------------------------------------------------

-- 1. å¤‰æ•°ã®åˆæœŸåŒ–ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨é€£å‹•ï¼‰
TORNADO_SPEED = TORNADO_SPEED or 4
TORNADO_RADIUS = TORNADO_RADIUS or 13.5
TORNADO_HEIGHT = TORNADO_HEIGHT or 23

CIRCLE_SPEED = CIRCLE_SPEED or 10
CIRCLE_RADIUS = CIRCLE_RADIUS or 13.5
CIRCLE_HEIGHT = CIRCLE_HEIGHT or 2

-- 2. æ—¢å­˜ã®é–¢æ•°ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‚ç…§å‹ã«ä¸Šæ›¸ã
function startTornado()
    if tornadoConn then tornadoConn:Disconnect() end
    rescan()  
    tornadoConn = RunService.Heartbeat:Connect(function(dt)  
        local baseCF = _G.CurrentBaseCF or (HRP() and HRP().CFrame)
        if not baseCF or #list == 0 then return end  
        tAccum = tAccum + dt  
        for i, rec in ipairs(list) do  
            local p = rec.part  
            if p and p.Parent then  
                local heightOffset = (i / #list) * TORNADO_HEIGHT  
                local angle = (tAccum * (TORNADO_SPEED / 2)) + (i * math.pi * 2 / #list)  
                local x = math.cos(angle) * TORNADO_RADIUS  
                local z = math.sin(angle) * TORNADO_RADIUS  
                local targetCFrame = baseCF * CFrame.new(x, heightOffset, z) * CFrame.Angles(0, angle, 0)  
                if p:FindFirstChild("BodyVelocity") then p.BodyVelocity.Velocity = (targetCFrame.Position - p.Position) * 30 end  
                if p:FindFirstChild("BodyGyro") then p.BodyGyro.CFrame = targetCFrame end  
            end  
        end  
    end)
end

function startCircle()
    if circleConn then circleConn:Disconnect() end
    rescan()  
    circleConn = RunService.Heartbeat:Connect(function(dt)  
        local baseCF = _G.CurrentBaseCF or (HRP() and HRP().CFrame)
        if not baseCF or #list == 0 then return end  
        tAccum = tAccum + dt  
        for i, rec in ipairs(list) do  
            local p = rec.part  
            if p and p.Parent then  
                local angle = (i / #list) * math.pi * 2 + (tAccum * (CIRCLE_SPEED / 2))  
                local x = math.cos(angle) * CIRCLE_RADIUS  
                local z = math.sin(angle) * CIRCLE_RADIUS  
                local targetCFrame = baseCF * CFrame.new(x, CIRCLE_HEIGHT, z) * CFrame.Angles(0, angle, 0)  
                if p:FindFirstChild("BodyVelocity") then p.BodyVelocity.Velocity = (targetCFrame.Position - p.Position) * 30 end  
                if p:FindFirstChild("BodyGyro") then p.BodyGyro.CFrame = targetCFrame end  
            end  
        end  
    end)
end

-- 3. UIã«ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’è¡¨ç¤ºã•ã›ã‚‹
WingTab:AddSection({Name = "ğŸŒªï¸ ç«œå·»ãƒ¢ãƒ¼ãƒ‰ãƒ»ã‚«ã‚¹ã‚¿ãƒ "})

WingTab:AddSlider({
    Name = "ç«œå·» é€Ÿåº¦", Min = 1, Max = 50, Default = 4, Increment = 1,
    Callback = function(v) TORNADO_SPEED = v end
})
WingTab:AddSlider({
    Name = "ç«œå·» åŠå¾„", Min = 1, Max = 100, Default = 13, Increment = 1,
    Callback = function(v) TORNADO_RADIUS = v end
})
WingTab:AddSlider({
    Name = "ç«œå·» é«˜ã•", Min = 1, Max = 150, Default = 23, Increment = 1,
    Callback = function(v) TORNADO_HEIGHT = v end
})

WingTab:AddSection({Name = "â­• å††ãƒ¢ãƒ¼ãƒ‰ãƒ»ã‚«ã‚¹ã‚¿ãƒ "})

WingTab:AddSlider({
    Name = "å†† é€Ÿåº¦", Min = 1, Max = 50, Default = 10, Increment = 1,
    Callback = function(v) CIRCLE_SPEED = v end
})
WingTab:AddSlider({
    Name = "å†† åŠå¾„", Min = 1, Max = 100, Default = 13, Increment = 1,
    Callback = function(v) CIRCLE_RADIUS = v end
})
WingTab:AddSlider({
    Name = "å†† é«˜ã•", Min = -20, Max = 100, Default = 2, Increment = 1,
    Callback = function(v) CIRCLE_HEIGHT = v end
})

OrionLib:MakeNotification({Name = "UIæ›´æ–°", Content = "ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å±•é–‹ã—ã¾ã—ãŸã€‚", Time = 4})
